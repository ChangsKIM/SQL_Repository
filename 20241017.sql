-- 2024/10/17

-- 조인
-- inner join : 두 테이블에서 조건이 일치하는 행만 반환
-- 동일, 자연, 크로스 조인이 있음
CREATE TABLE A(
    CODE CHAR(1),
    VAL NUMBER(1)
);
CREATE TABLE B(
    CODE CHAR(1),
    UNIT CHAR(1)
);
INSERT INTO A VALUES('A',1);
INSERT INTO A VALUES('B',2);
INSERT INTO A VALUES('C',3);
INSERT INTO A VALUES('D',4);

INSERT INTO B VALUES('A','+');
INSERT INTO B VALUES('B','-');
INSERT INTO B VALUES('C','*');
INSERT INTO B VALUES('F','/');

SELECT * FROM A;
SELECT * FROM B;

-- 동일 조인(EQUI JOIN)
-- 방법01
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A, B
WHERE A.CODE = B.CODE;
-- 방법02 <선호01>
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A INNER JOIN B
ON A.CODE = B.CODE;
-- INNER JOIN(내부조인)
-- 	조인 조건을 만족하는 모든 행을 결합
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A INNER JOIN B
ON A.CODE <> B.CODE;
-- 방법03 <선호02>
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A JOIN B
ON A.CODE = B.CODE;

-- 자연 조인(NATURAL JOIN)
SELECT * FROM A NATURAL JOIN B;

-- 크로스 조인(CROSS JOIN)
SELECT * FROM A CROSS JOIN B;


-----------------------------------------------------------------
-----------------------------------------------------------------
-- 연습문제03
-- 학생 테이블을 이용한 조인 예제

-- 학생 테이블에 학과명만 중복없이 조회
SELECT DISTINCT STD_MAJOR FROM STUDENT;
SELECT DISTINCT STD_MAJOR FROM STUDENT;

-- 학과명, 행번호
SELECT 
	TO_CHAR(ROWNUM, 'FM00') AS 학과번호, 
	STD_MAJOR AS 학과명
FROM (SELECT DISTINCT STD_MAJOR FROM STUDENT);


-- 01. 학과 테이블 생성
CREATE TABLE MAJOR
AS 
SELECT 
	TO_CHAR(ROWNUM, 'FM00') AS 학과번호, 
	STD_MAJOR AS 학과명
FROM (SELECT DISTINCT STD_MAJOR FROM STUDENT);

SELECT * FROM MAJOR;

-- 02. 학생 테이블에 학과 컬럼 추가
ALTER TABLE STUDENT
ADD MAJOR_NO VARCHAR2(3);

-- 03. 학생 테이블에 학과 번호 업데이트
UPDATE STUDENT 
	SET MAJOR_NO = 
		(SELECT MAJOR_NO FROM MAJOR WHERE MAJOR_NAME = STD_MAJOR);

SELECT * FROM STUDENT;

-- 04. 학생 테이블의 학과명 컬럼 삭제
ALTER TABLE STUDENT DROP COLUMN STD_MAJOR;

-- 05. 학생정보 조회시 학번, 이름, 학과명, 평점 조회
-- 동일 조인
SELECT S.STD_NO, S.STD_NAME, M.MAJOR_NAME, S.STD_SCORE
FROM STUDENT S 
JOIN MAJOR M 
ON S.MAJOR_NO = M.MAJOR_NO ;

-- 자연 조인
SELECT * 
FROM STUDENT 
NATURAL JOIN MAJOR;

-- 크로스 조인
SELECT * FROM STUDENT CROSS JOIN MAJOR;


-----------------------------------------------------------------


-- 제조사 테이블 생성
CREATE TABLE MANUFACTURERS (
    MANUFACTURER_ID CHAR(10) PRIMARY KEY,   -- 제조사번호
    MANUFACTURER_NAME VARCHAR2(60)  -- 제조사명
);

SELECT * FROM MANUFACTURERS;
DROP TABLE MANUFACTURERS;

-- 제품 테이블 생성
CREATE TABLE PRODUCTS (
    PRODUCT_ID CHAR(10) PRIMARY KEY,        -- 제품번호
    PRODUCT_NAME VARCHAR2(120),  -- 제품명
    MANUFACTURER_ID CHAR(10),   -- 제조사번호
    PRICE NUMBER,             -- 금액
    FOREIGN KEY (MANUFACTURER_ID) REFERENCES MANUFACTURERS(MANUFACTURER_ID)
);


-- 제품 정보 조회시
-- 제품번호, 제품명, 제조사명, 금액
SELECT 
    P.PRODUCT_ID,
    P.PRODUCT_NAME,
    M.MANUFACTURER_NAME,
    P.PRICE 
FROM MANUFACTURERS M 
JOIN PRODUCTS P 
ON M.MANUFACTURER_ID = P.MANUFACTURER_ID;

-----------------------------------------------------------------------

-- 장학금 테이블
-- 데이터 30건 추가
CREATE TABLE STUDENT_SCHOLARSHIP(
	SCHOLARSHIP_NO NUMBER,
	STD_NO CHAR(8),
	MONEY NUMBER
);

SELECT * FROM STUDENT_SCHOLARSHIP;

SELECT 
    SS.SCHOLARSHIP_NO,
    S.STD_NO,
    SS.MONEY     
FROM STUDENT S 
JOIN STUDENT_SCHOLARSHIP SS 
ON S.STD_NO = SS.STD_NO;

-- 문제01 ; 장학금을 받는 학생 조회
SELECT
	SS.SCHOLARSHIP_NO,
	S.STD_NAME, 
	S.STD_NO,
	SS.MONEY
FROM STUDENT S JOIN STUDENT_SCHOLARSHIP SS
ON S.STD_NO = SS.STD_NO ;

-- 문제02 ; 장학금을 받는 학생 조회시
-- 학번, 이름, 학과명, 평점, 성별, 받은 금액

SELECT
	SS.SCHOLARSHIP_NO,
	S.STD_NAME, 
	S.STD_NO,
	SS.MONEY,
	M.MAJOR_NAME,
	S.STD_SCORE,
	S.STD_GENDER 
FROM STUDENT S 
JOIN STUDENT_SCHOLARSHIP SS ON S.STD_NO = SS.STD_NO
JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO; 
-- FROM 순서는 상관 없음 / 조인 결정은 ON에서 실시 / ON에서 조인을 실시하면 SELECT에서 출력함

-- 학과 테이블 데이터 2건 추가
INSERT INTO MAJOR VALUES('A9', '국어국문학과');
INSERT INTO MAJOR VALUES('B2', '생활체육학과');
	
-- 외부 조인(OUTER JOIN)
-- 조인 조건에 맞지 않는 행도 결과에 포함시킬 때 사용하는 조인
-- A : A=1,B=2,C=3,D=4 
-- B : A=+,B=-,C=*,F=/

-- LEFT OUTER JOIN
SELECT A.*, B.*
FROM A LEFT OUTER JOIN B ON A.CODE = B.CODE ;


-- RIGHT OUTER JOIN
SELECT A.*, B.*
FROM A RIGHT OUTER JOIN B ON A.CODE = B.CODE ;

-- FULL JOIN 
SELECT A.*, B.*
FROM A 
FULL OUTER JOIN B ON A.CODE = B.CODE ;

---------------------------------------------------------------------------
---------------------------------------------------------------------------

-- 연습문제01
-- 학생 정보 출력시 학생테이블, 학과 테이블에 있는 모든 데이터를 조회
-- 모든 컬럼 조회, 연결되지 않는 학과도 전부 조회
SELECT
S.*, M.*
FROM STUDENT S RIGHT OUTER JOIN MAJOR M
ON S.MAJOR_NO = M.MAJOR_NO; -- STE_NO, STD_NAME, STD_SCORE, STD_GENDER = NULL

-- 연습문제02
-- 학생이 한명도 없는 학과를 조회
SELECT
    M.*, S.STD_NO 
FROM STUDENT S 
RIGHT OUTER JOIN MAJOR M 
ON S.MAJOR_NO = M.MAJOR_NO
WHERE S.STD_NAME IS NULL;

-- 연습문제03
-- 장학금을 받지 못한 학생들의 정보를 조회
SELECT
	SS.SCHOLARSHIP_NO,
	S.STD_NAME, 
	S.STD_NO,
	SS.MONEY
FROM STUDENT S 
LEFT OUTER JOIN STUDENT_SCHOLARSHIP SS
ON S.STD_NO = SS.STD_NO
WHERE SS.SCHOLARSHIP_NO IS NULL ;

-- 학과명 추가
SELECT
	SS.SCHOLARSHIP_NO,
	S.STD_NAME, 
	S.STD_NO,
	S.STD_GENDER,
	M.MAJOR_NAME,
	SS.MONEY
FROM STUDENT S 
LEFT OUTER JOIN STUDENT_SCHOLARSHIP SS
ON S.STD_NO = SS.STD_NO
JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO;
WHERE SS.SCHOLARSHIP_NO IS NULL

-- 연습문제04(JOIN, GROUP BY)
-- 학과별로 장학금을 받은 학생들의 학과별, 성별을 기준으로 인원수, 최고평점, 최저평점 조회
SELECT
	M.MAJOR_NAME AS 학과명,
	S.STD_GENDER AS 성별,
	COUNT(*) AS 인원수,
	MAX(S.STD_SCORE) AS 최고평점,
	MIN(S.STD_SCORE) AS 최소평점
FROM STUDENT S
JOIN STUDENT_SCHOLARSHIP SS ON S.STD_NO = SS.STD_NO
JOIN MAJOR M ON S.MAJOR_NO = M.MAJOR_NO
GROUP BY ROLLUP(M.MAJOR_NAME, S.STD_GENDER);
-- WHERE
SELECT 
	M.MAJOR_NAME, S.STD_GENDER, 
	COUNT(*) AS STD_COUNT, 
	MAX(S.STD_SCORE) AS MAX_SCORE,
	MIN(S.STD_SCORE) AS MIN_SCORE 
FROM STUDENT S , MAJOR M, STUDENT_SCHOLARSHIP SS
WHERE S.MAJOR_NO = M.MAJOR_NO AND S.STD_NO = SS.STD_NO
GROUP BY M.MAJOR_NAME, S.STD_GENDER;

-- 연습문제05(JOIN, GROUP BY)
-- 학과별로 장학금을 못받은 학생들 숫자를 조회
-- 학과명, 학생수만 출력
SELECT
	M.MAJOR_NAME AS 학과명,
	COUNT(*) AS 인원수
FROM STUDENT S 
LEFT OUTER JOIN STUDENT_SCHOLARSHIP SS
ON S.STD_NO = SS.STD_NO
JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
WHERE SS.SCHOLARSHIP_NO IS NULL
GROUP BY M.MAJOR_NAME;

--------------------------------------------------------------------
--------------------------------------------------------------------

-- CAR TABLE 
-- 제조사 코드 형식 AA-0-000
SELECT DBMS_RANDOM.STRING('X', 2) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(0,10),0) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(100,1000),0)
FROM DUAL;

-- TABLE 생성 CARSELL(판매)
CREATE TABLE CAR_SELL(
	CAR_SELL_NO NUMBER PRIMARY KEY,
	CAR_ID VARCHAR2(10),
	CAR_SELL_EA NUMBER(3),
	CAR_SELL_PRICE NUMBER(10),
	CAR_SELL_DATE DATE DEFAULT SYSDATE
);

-- 자동차 제조사만 조회 _ 중복 내용 제거
SELECT DISTINCT CAR_MAKER AS 제조사 FROM CAR;

-- 자동차 제조사 코드, 자동차 제조사명
SELECT 
	DBMS_RANDOM.STRING('X', 2) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(0,10),0) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(100,1000),0) AS CAR_MARKER_CODE,
	CAR_MAKER 
FROM (SELECT DISTINCT CAR_MAKER FROM CAR) ;

-- 자동차 제조사 테이블 생성
CREATE TABLE CAR_MAKER
AS
SELECT
	DBMS_RANDOM.STRING('X', 2) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(0,10),0) || '-' ||
	TRUNC(DBMS_RANDOM.VALUE(100,1000),0) AS CAR_MARKER_CODE,
	CAR_MAKER AS CAR_MAKER_NAME
FROM (SELECT DISTINCT CAR_MAKER FROM CAR) ;


-- 자동차 테이블에 제조사 코드 컬럼 추가
ALTER TABLE CAR ADD CAR_MAKER_CODE VARCHAR2(10);

-- 자동차 테이블에 제조사 코드 컬럼 수정
UPDATE CAR C SET C.CAR_MAKER_CODE = 
(SELECT CM.CAR_MARKER_CODE 
	FROM CAR_MAKER CM
	WHERE C.CAR_MAKER = CM.CAR_MAKER_NAME);

-- 자동차 테이블에 제조사명 컬럼 삭제
ALTER TABLE CAR DROP COLUMN CAR_MAKER;


-- 자동차 정보 조회시 ; 자동차 번호, 자동차 모델명, 제조사명, 제조년도, 금액
SELECT 
	c.CAR_ID ,
	cm.CAR_MAKER_NAME ,
	c.CAR_MAKER_CODE ,
	c.CAR_MAKE_YEAR ,
	c.CAR_PRICE 
FROM CAR c 
LEFT OUTER JOIN CAR_MAKER cm ON c.CAR_MAKER_CODE = cm.CAR_MARKER_CODE ;


-- 자동차 제조사별 자동차 제품 개수, 평균가, 최고가, 최소가 조회
SELECT 
	cm.CAR_MAKER_NAME ,
	TRUNC(AVG(c.CAR_PRICE)), COUNT(*), 
	MAX(c.CAR_PRICE),
	MIN(c.CAR_PRICE)	
FROM CAR c 
LEFT OUTER JOIN CAR_MAKER cm 
ON c.CAR_MAKER_CODE = cm.CAR_MARKER_CODE 
GROUP BY cm.CAR_MAKER_NAME ;

-- 자동차 제조사별, 제조년도별, 출시된 제품 개수를 조회
-- 단, 금액이 10,000이상인 것들만 대상으로 출력
SELECT 
	CM.CAR_MAKER_NAME, 
	C.CAR_MAKE_YEAR, 
	COUNT(*) 
FROM CAR C
LEFT OUTER JOIN CAR_MAKER CM
ON C.CAR_MAKER_CODE = CM.CAR_MARKER_CODE
WHERE C.CAR_PRICE < 10000
GROUP BY CM.CAR_MAKER_NAME, C.CAR_MAKE_YEAR;

-- 자동차 판매 정보 조회
-- 판매 번호, 판매된 모델명, 판매일, 판매개수, 판매금액
SELECT 
	CS.CAR_SELL_NO ,
	C.CAR_ID ,
	C.CAR_MAKER_CODE ,
	CS.CAR_SELL_DATE ,
	CS.CAR_SELL_EA ,
	CS.CAR_SELL_PRICE 
FROM CAR C
LEFT OUTER JOIN CAR_SELL CS
ON C.CAR_ID = CS.CAR_ID ;


-- 한번도 판매되지 않은 자동차 목록 조회
-- 자동차 번호, 자동차 모델명, 제조사명, 제조년도, 금액
SELECT
	C.CAR_ID ,
	CM.CAR_MAKER_NAME ,
	C.CAR_MAKE_YEAR ,
	C.CAR_PRICE 
FROM CAR C
LEFT OUTER JOIN CAR_SELL CS
ON C.CAR_ID = CS.CAR_ID 
JOIN CAR_MAKER CM
ON C.CAR_MAKER_CODE = CM.CAR_MARKER_CODE 
WHERE CS.CAR_ID IS NULL;

-- 판매 연도별, 제조사별, 판매 대수 총합, 판매금액 총합, 판매금액 평균을 조회
SELECT
	TO_CHAR(CS.CAR_SELL_DATE, 'YYYY') AS 판매년도 ,
	CM.CAR_MAKER_NAME AS 제조사 ,
	SUM(CS.CAR_SELL_EA) AS "판매 대수 총합",
	SUM(CS.CAR_SELL_PRICE) AS "판매금액 총합" ,
	TRUNC(AVG(CS.CAR_SELL_PRICE)) AS "판매금액 평균"	
FROM CAR C
LEFT OUTER JOIN CAR_SELL CS
ON C.CAR_ID = CS.CAR_ID
JOIN CAR_MAKER CM 
ON C.CAR_MAKER_CODE = CM.CAR_MARKER_CODE
GROUP BY TO_CHAR(CS.CAR_SELL_DATE, 'YYYY') , CM.CAR_MAKER_NAME ;

-- 판매 연도/원별, 제조사별, 판매 대수 총합, 판매금액 총합, 판매금액 편균을 조회
SELECT
	TO_CHAR( CS.CAR_SELL_DATE, 'YYYY/MM') AS 판매년도 ,
	CM.CAR_MAKER_NAME AS 제조사 ,
	SUM(CS.CAR_SELL_EA) AS "판매 대수 총합",
	SUM(CS.CAR_SELL_PRICE) AS "판매금액 총합" ,
	TRUNC(AVG(CS.CAR_SELL_PRICE), 2) AS "판매금액 평균"	
FROM CAR C
LEFT OUTER JOIN CAR_SELL CS
ON C.CAR_ID = CS.CAR_ID
JOIN CAR_MAKER CM 
ON C.CAR_MAKER_CODE = CM.CAR_MARKER_CODE
GROUP BY TO_CHAR(CS.CAR_SELL_DATE, 'YYYY/MM') , CM.CAR_MAKER_NAME ;

-- 판매 연도/분기, 판매 대수 총합, 판매금액 총합, 판매금액 평균을 조회
SELECT
	TO_CHAR( CS.CAR_SELL_DATE, 'YYYY/Q') AS 판매년도 ,
	SUM(CS.CAR_SELL_EA) AS "판매 대수 총합",
	SUM(CS.CAR_SELL_PRICE) AS "판매금액 총합" ,
	TRUNC(AVG(CS.CAR_SELL_PRICE), 2) AS "판매금액 평균"	
FROM CAR C
LEFT OUTER JOIN CAR_SELL CS
ON C.CAR_ID = CS.CAR_ID
JOIN CAR_MAKER CM 
ON C.CAR_MAKER_CODE = CM.CAR_MARKER_CODE
GROUP BY TO_CHAR(CS.CAR_SELL_DATE, 'YYYY/Q') ;

--------------------------------------------------------------------
--------------------------------------------------------------------

-- 2024/10/18

-- 제약조건 
SELECT * FROM USER_CONSTRAINTS;

-- 기본키 
-- ALTER TABLE 테이블명 ADD CONSTRAINTS 제약명 PRIMARY KEY(기본키로 지정할 컬럼)
DROP TABLE PERSON;

-- PERSON TABLE 생성
CREATE TABLE PERSON(
	PID CHAR(4),
	PNAME VARCHAR2(30 BYTE),
	AGE NUMBER(3, 0)
);

-- 제약조건
ALTER TABLE PERSON 
ADD CONSTRAINT PERSON_PID_PK
PRIMARY KEY(PID);

-- 제약조건 확인
SELECT * FROM USER_CONSTRAINTS;

-- 데이터 추가

INSERT INTO PERSON VALUES('0001','홍길동',20);
INSERT INTO PERSON VALUES('0002','김길동',30);
INSERT INTO PERSON VALUES('0003','이길동',40);
INSERT INTO PERSON VALUES('0004','박길동',50);

-- 외래키
ALTER TABLE 테이블명 ADD CONSTRAINTS 제약조건명 
FOREIGN KEY(외래키 지정할 컬럼명) -- 서브
REFERENCES 외래키로 연결될 테이블명(참조할 테이블의 기본키) -- 메인
[ON DELETE CASCADE] | [ON DELETE RESTRICT] | [ON DELETE SET NULL]
-- ON DELETE CASCADE ; 부모 테이블에서 행이 삭제될 때, 
-- ON DELETE RESTRICT ; 부모 테이블에서 행을 삭제하려고 할 때, 그 행을 참조하는 자식 테이블에 데이터가 남아 있다면 삭제를 제한
-- ON DELETE SET NULL ; 부모 테이블에서 행이 삭제될 때, 그 행을 참조하는 자식 테이블의 외래키 값을 NULL로 설정

-- EX)
CREATE TABLE PERSON_ORDER(
	P_ORDER_NO NUMBER(5),
	P_ORDER_MEMO VARCHAR2(300),
	P_ID CHAR(4)
);
-- PERSON_ORDER에 P_ORDER_NO를 기본키로 작성
ALTER TABLE PERSON_ORDER 
ADD CONSTRAINT PERSON_ORDER_PO_NO_PK
PRIMARY KEY(P_ORDER_NO);

-- 제약조건 확인
SELECT * FROM USER_CONSTRAINTS;

-- PERSON_ORDER에 PID를 외래키 설정, PERSON에 있는 PID와 연결
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_PID_FK
FOREIGN KEY(P_ID) REFERENCES PERSON(PID);

-- 데이터 추가(외래키 확인)
INSERT INTO PERSON_ORDER VALUES(1, '지시 내용01', '0001');
INSERT INTO PERSON_ORDER VALUES(2, '지시 내용02', '0002');
INSERT INTO PERSON_ORDER VALUES(3, '지시 내용03', '0003');
INSERT INTO PERSON_ORDER VALUES(4, '지시 내용04', '0004');
-- 에러, PERSON 테이블에 해당 PID 값이 없을 때 > 참조 무결성
INSERT INTO PERSON_ORDER VALUES(5, '지시 내용05', '0005');

-- PERSON의 기본키 삭제 ; 제약조건 위배(자식 레코드를 먼저 삭제)
DELETE FROM PERSON WHERE PID LIKE '0001';

-- PERSON_ORDER에서 삭제
DELETE FROM PERSON_ORDER WHERE P_ID LIKE '0001';

-- PERSON_ORDER에 외래키 제약조건 삭제
ALTER TABLE PERSON_ORDER DROP CONSTRAINT PERSON_ORDER_PID_FK;

-- 외래키 지정시 ON DELETE CASCADE 지정
ALTER TABLE PERSON_ORDER
ADD CONSTRAINT PERSON_ORDER_PID_FK
FOREIGN KEY(P_ID) REFERENCES PERSON(PID) ON DELETE CASCADE;

-- 부모 테이블 '0002'삭제
DELETE FROM PERSON WHERE PID LIKE '0002' 

-- PERSON_ORDER에 외래키 제약조건 삭제
ALTER TABLE PERSON_ORDER DROP CONSTRAINT PERSON_ORDER_PID_FK;

-- 외래키 지정시 ON DELETE SET NULL 지정
ALTER TABLE PERSON_ORDER
ADD CONSTRAINT PERSON_ORDER_PID_FK
FOREIGN KEY(P_ID) REFERENCES PERSON(PID) ON DELETE SET NULL;

-- 자식 테이블 '0003'삭제
DELETE FROM PERSON WHERE PID LIKE '0003'

SELECT * FROM PERSON;
SELECT * FROM PERSON_ORDER;

-- PERSON 테이블 삭제
-- 자식 테이블이 있어 삭제 불가. 
-- 따라서, CASCADE CONSTRAINTS; 자식 테이블은 살리고 부모테이블만 삭제
DROP TABLE PERSON CASCADE CONSTRAINTS;


-- 외래키 실습
-- MAJOR에 기본키 설정
ALTER TABLE MAJOR ADD CONSTRAINT MAJOR_MAJOR_NO_PK
PRIMARY KEY(MAJOR_NO);

-- STUDENT 테이블의 학과번호를 외래키로 지정, MAJOR 테이블의 학과번호로 지정
ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_MAJOR_NO_FK
FOREIGN KEY (MAJOR_NO) 
REFERENCES MAJOR(MAJOR_NO) ON DELETE CASCADE;

SELECT S.*, M.MAJOR_NO 
FROM STUDENT s LEFT OUTER JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO 
WHERE M.MAJOR_NO IS NULL;

-- 장학금 테이블 학번 외래키 지정
ALTER TABLE STUDENT_SCHOLARSHIP 
ADD CONSTRAINT STUDENT_SCHOLARSHIP_STD_NO_FK
FOREIGN KEY(STD_NO)
REFERENCES STUDENT (STD_NO) ON DELETE CASCADE; 


-- check
-- 컴럼에 들어올 값의 범위 및 제약 조건을 거는 방법
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 CHECK(조건식);

-- PERSON 테이블에 나이가 0보다 큰 값만 저장될 수 있는 제약조건 설정
ALTER TABLE PERSON
ADD CONSTRAINT PERSON_AGE_CHK 
CHECK(AGE > 0);

-- 데이터 추가
INSERT INTO PERSON VALUES('0005', '임걱정', 40); -- 데이터 입력
INSERT INTO PERSON VALUES('0006', '김창수', -38); -- 체크 제약조건 위배

-- CHECK 제약조건 비활성화
ALTER TABLE PERSON DISABLE CONSTRAINT PERSON_AGE_CHK;
-- CHECK 제약조건 활성화
ALTER TABLE PERSON ENABLE CONSTRAINT PERSON_AGE_CHK;
-- 제약조건 삭제
ALTER TABLE PERSON(테이블명) DROP CONSTRAINT PERSON_AGE_CHK(제약조건명);

-- PERSON 테이블에 데이터 추가시 이름에 공백이 들어가지 않도록 제약조건을 설정
-- 방법01
ALTER TABLE PERSON
ADD CONSTRAINT PERSON_PNAME_CHK 
CHECK (PNAME NOT LIKE '% %');
-- 방법02
ALTER TABLE PERSON
ADD CONSTRAINT PERSON_PNAME_CHK 
CHECK (INSET(PNAME NOT LIKE '') = 0); 

INSERT INTO PERSON VALUES('0006', '이순신 ', 66); -- 데이터 입력 불가

SELECT * FROM PERSON; -- 정보 조회

ALTER TABLE PERSON DROP CONSTRAINT PERSON_PNAME_CHK; -- 제약조건 삭제


-- 학생 테이블에 평점이 0.0 ~ 4.5까지만 저장되게끔 제약조건 추가
ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_SCORE_CHK
CHECK(STD_SCORE > 0 AND STD_SCORE < 4.5);
-- CHECK(STD_SCORE BETWEEN 0 AND 4.5)

-- 서브쿼리(Sub Query)
-- 하나의 sql문에 또 다른 sql문이 있는 형태
-- 단일 행, 멀티 행, 다중 컬럼, 스칼라

-- 연습문제 01
-- 조건식에 들어가는 서브쿼리(단일 행 서브쿼리;SINGLE-ROW SUBQUERY)
-- 평점이 최고점에 해당하는 학생 정보 조회
SELECT * FROM STUDENT 
WHERE STD_SCORE = (SELECT MAX(STD_SCORE) FROM STUDENT);  


-- 연습문제 02
-- 평점이 최저점인 학생 데이터 삭제
DELETE FROM STUDENT 
WHERE STD_SCORE = (SELECT MIN(STD_SCORE) FROM STUDENT);
-- 조회
SELECT * FROM STUDENT 
WHERE STD_SCORE = (SELECT MIN(STD_SCORE) FROM STUDENT);

-- 연습문제 03
-- 평점이 최고점인 학생과 최저점인 학생 조회
-- 조회할 컬럼은 학번, 이름, 학과명, 평점, 성별
SELECT 
	S.STD_NO AS 학번,
	S.STD_NAME AS 이름,
	M.MAJOR_NAME AS 학과명,
	S.STD_SCORE AS 평점,
	S.STD_GENDER AS 성별
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
WHERE STD_SCORE IN((SELECT MIN(STD_SCORE) FROM STUDENT), 
				   (SELECT MAX(STD_SCORE) FROM STUDENT));
				  
-- 연습문제 04
-- 평균 이하인 학생들의 평점을 0.5점 증가
UPDATE STUDENT SET STD_SCORE = STD_SCORE + 0.5
WHERE STD_SCORE <=(SELECT AVG(STD_SCORE) FROM STUDENT);


-- 연습문제 05
-- 장학금 받은 학생들만 조회. 학번, 이름, 학과명, 평점
-- 방법01
SELECT 
	ss.SCHOLARSHIP_NO AS 학번, 
	s.STD_NAME AS 이름, 
	s.STD_SCORE AS 평점, 
	ss.MONEY AS 금액 
FROM STUDENT s 
JOIN STUDENT_SCHOLARSHIP ss ON s.STD_NO = ss.STD_NO
JOIN MAJOR m ON s.MAJOR_NO = m.MAJOR_NO ;

-- 방법02
SELECT 
S.STD_NO AS 학번,
	S.STD_NAME AS 이름,
	M.MAJOR_NAME AS 학과명,
	S.STD_SCORE AS 평점,
	S.STD_GENDER AS 성별
FROM STUDENT s 
JOIN MAJOR m ON s.MAJOR_NO = m.MAJOR_NO
WHERE s.STD_NO IN (SELECT ss.STD_NO FROM STUDENT_SCHOLARSHIP ss);

-- 방법02-1 (장학금을 받지 못한 학생 조회_불일치 쿼리)
SELECT 
S.STD_NO AS 학번,
	S.STD_NAME AS 이름,
	M.MAJOR_NAME AS 학과명,
	S.STD_SCORE AS 평점,
	S.STD_GENDER AS 성별
FROM STUDENT s 
JOIN MAJOR m ON s.MAJOR_NO = m.MAJOR_NO
WHERE s.STD_NO NOT IN (SELECT ss.STD_NO FROM STUDENT_SCHOLARSHIP ss);

-- 연습문제 06
-- 학과별로 최고점을 가진 학생들을 조회
-- 01. 일반 조회
SELECT
	m.MAJOR_NAME AS 학과,
	MAX(s.STD_SCORE) AS 최고점수 
FROM STUDENT s JOIN MAJOR m ON s.MAJOR_NO = m.MAJOR_NO 
GROUP BY m.MAJOR_NAME , s.STD_SCORE; 

-- 02. 서브 쿼리를 이용해서 다중 컬럼 비교
SELECT * FROM STUDENT
WHERE (MAJOR_NO, STD_SCORE) 
IN (SELECT MAJOR_NO, MAX(STD_SCORE) 
FROM STUDENT GROUP BY MAJOR_NO);

-- 03. 조인을 이용해서 조회
SELECT s.* FROM STUDENT s 
JOIN (SELECT MAJOR_NO, MAX(STD_SCORE) AS MAX_SCORE FROM STUDENT 
GROUP BY MAJOR_NO) m 
ON s.MAJOR_NO = m.MAJOR_NO AND s.STD_SCORE = m.MAX_SCORE;

-- 연습문제 07
-- FROM 절에 들어가는 서브쿼리
-- 학생정보 조회시 행번호, 학번, 이름, 학과명, 평점 조회
-- 평점을 기준으로 내림차순 정렬

-- SELECT 후에 ORDER BY가 실행되기 때문에  ROWNUM이 뒤죽박죽한 상태가 됨
SELECT ROWNUM, S.STD_NO , S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE 
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
ORDER BY S.STD_SCORE DESC;

-- 서브 쿼리 적용 예
SELECT ROWNUM, S.*
FROM 
(SELECT ROWNUM, S.STD_NO , S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE 
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
ORDER BY S.STD_SCORE DESC) S;

-- 서브 쿼리 다른 예
SELECT ROW_NUMBER () OVER(ORDER BY S.STD_SCORE DESC),
S.STD_NO , S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE 
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO;

-- 제일 위에 데이터 5건만 조회
SELECT *
FROM (
SELECT ROWNUM AS 행번호, S.*
FROM 
(SELECT ROWNUM, S.STD_NO , S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE 
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
ORDER BY S.STD_SCORE DESC) S
) WHERE 행번호 <= 5;

-- 6번부터 10번까지 조회
SELECT *
FROM (
SELECT ROWNUM AS 행번호, S.*
FROM 
(SELECT ROWNUM, S.STD_NO , S.STD_NAME , M.MAJOR_NAME , S.STD_SCORE 
FROM STUDENT s JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO
ORDER BY S.STD_SCORE DESC) S
) WHERE 행번호 BETWEEN 6 AND 10;

-- 코드 줄이기
SELECT *
FROM (
    SELECT ROW_NUMBER() OVER (ORDER BY S.STD_SCORE DESC) AS 행번호, 
           S.STD_NO, 
           S.STD_NAME, 
           M.MAJOR_NAME, 
           S.STD_SCORE
    FROM STUDENT S
    JOIN MAJOR M ON S.MAJOR_NO = M.MAJOR_NO
) 
WHERE 행번호 BETWEEN 6 AND 10;


-- 장학금 받는 학생들 중 제일 많이 장학금을 받는 상행 TOP3 조회
-- 학번, 이름, 학과명, 장학금 금액
SELECT *
FROM (
SELECT
	DENSE_RANK () OVER(ORDER BY SS.MONEY DESC) AS 행번호,
	SS.SCHOLARSHIP_NO AS 장학금,
	S.STD_NAME AS 이름,
	S.STD_NO AS 번호,
	SS.MONEY AS 금액,
	M.MAJOR_NAME AS 학과명
FROM STUDENT s 
JOIN STUDENT_SCHOLARSHIP ss ON s.STD_NO = ss.STD_NO 
JOIN MAJOR m ON S.MAJOR_NO = M.MAJOR_NO 
) WHERE 행번호 <= 3;

-- 학생 정보 조회(SUB QUERY 이용)
-- 학번, 이름, 학과명, 평점
SELECT S.STD_NO , S.STD_NAME ,
	(SELECT M.MAJOR_NAME 
	FROM MAJOR m WHERE S.MAJOR_NO = M.MAJOR_NO) AS MAJOR_NAME,
	S.STD_SCORE
FROM STUDENT s ;



